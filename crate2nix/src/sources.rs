//! Manage nix-generated Cargo workspaces.

use crate::{
    config,
    prefetch::PrefetchableSource,
    resolve::{CratesIoSource, GitSource},
};
use anyhow::{bail, format_err, Context, Error};
use semver::Version;
use std::{
    borrow::Cow,
    path::{Path, PathBuf},
};
use std::{fs::File, io::BufRead, process::Command, time::SystemTime};
use url::Url;

/// Returns the completed Source::CratesIo definition by prefetching the hash.
pub fn crates_io_source(name: String, version: Version) -> Result<config::Source, Error> {
    let prefetchable = CratesIoSource {
        name: name.clone(),
        version: version.clone(),
        sha256: None,
    };

    eprint!("Prefetching {}: ", prefetchable.to_string());
    let sha256 = prefetchable.prefetch()?;
    eprintln!("done.");

    Ok(config::Source::CratesIo {
        name,
        version,
        sha256,
    })
}

/// Returns the completed Source::Git definition by prefetching the hash.
pub fn git_io_source(url: Url, rev: String) -> Result<config::Source, Error> {
    let prefetchable = GitSource {
        url: url.clone(),
        rev: rev.clone(),
        r#ref: None,
        sha256: None,
    };

    eprint!("Prefetching {}: ", prefetchable.to_string());
    let sha256 = prefetchable.prefetch()?;
    eprintln!("done.");

    Ok(config::Source::Git { url, rev, sha256 })
}

/// Operations on a virtual cargo workspace assembled via nix.
pub struct Workspace<'a> {
    crate2nix_json_path: Cow<'a, Path>,
}

const WORKSPACE_MEMBERS: &str = "workspace_members";

impl<'a> Workspace<'a> {
    /// Returns a new CrateConfig for the given path.
    pub fn new<P: Into<Cow<'a, Path>>>(path: P) -> Workspace<'a> {
        Workspace {
            crate2nix_json_path: path.into(),
        }
    }

    fn project_dir(&self) -> PathBuf {
        self.crate2nix_json_path
            .parent()
            .expect("config to have parent")
            .to_path_buf()
    }

    fn workspace_nix(&self) -> PathBuf {
        self.project_dir().join("workspace.nix")
    }

    fn cargo_toml(&self) -> PathBuf {
        self.project_dir().join("Cargo.toml")
    }

    fn cargo_lock(&self) -> PathBuf {
        self.project_dir().join("Cargo.lock")
    }

    /// Create a config-nix if it doesn't exist yet.
    pub fn regenerate_workspace_nix(&self) -> Result<(), Error> {
        let info = crate::GenerateInfo::default();

        if !self.crate2nix_json_path.exists() {
            bail!(
                "Did not find config at '{}'.",
                self.crate2nix_json_path.to_string_lossy()
            );
        }

        crate::render::WORKSPACE_NIX.write_to_file(&self.workspace_nix(), &info)?;

        Ok(())
    }

    /// Create or update Cargo.toml/Cargo.lock file for the virtual workspace.
    pub fn update_cargo_files_if_inputs_modified(
        &self,
        workspace_member_dir: Option<PathBuf>,
    ) -> Result<(), Error> {
        if !self.crate2nix_json_path.exists() {
            bail!(
                "{} doesn't exist.",
                self.crate2nix_json_path.to_string_lossy()
            );
        }

        let inputs = [self.crate2nix_json_path.as_ref()];

        let last_modified: fn(&std::path::Path) -> Option<SystemTime> =
            |f: &std::path::Path| f.metadata().ok().and_then(|m| m.modified().ok());
        let input_last_modified: SystemTime = inputs
            .iter()
            .flat_map(|f| last_modified(f))
            .max()
            .unwrap_or_else(SystemTime::now);
        // Cargo.lock may remain unchanged but must exist.
        let outputs = [&self.cargo_toml(), &self.workspace_nix()];
        let output_last_modified: SystemTime = outputs
            .iter()
            .flat_map(|f| last_modified(f))
            .min()
            .unwrap_or(SystemTime::UNIX_EPOCH);
        if !self.cargo_lock().exists()
            || outputs.iter().any(|f| !f.exists())
            || output_last_modified < input_last_modified
        {
            self.update_cargo_files(workspace_member_dir)
        } else {
            eprintln!("Cargo files for out-of-tree sources are up-to-date.");
            Ok(())
        }
    }

    /// Create or update Cargo.toml/Cargo.lock file for the virtual workspace.
    pub fn update_cargo_files(&self, workspace_member_dir: Option<PathBuf>) -> Result<(), Error> {
        if self.cargo_toml().exists() {
            let reader = std::io::BufReader::new(File::open(&self.cargo_toml())?);
            let generated = reader.lines().any(|l| {
                l.map(|l| l.contains("@generated by crate2nix"))
                    .unwrap_or(false)
            });
            if !generated {
                bail!("Cowardly refusing to overwrite Cargo.toml without generated marker.");
            }
        }

        let workspace_member_dir_symlink = self.project_dir().join(WORKSPACE_MEMBERS);
        match workspace_member_dir {
            Some(workspace_member_dir) => {
                // Prebuilt, symlink because cargo requires it to be a sub directory.
                if workspace_member_dir_symlink.exists() {
                    std::fs::remove_file(&workspace_member_dir_symlink)
                        .context("while trying to remove existing workspace symlink")?;
                }
                std::os::unix::fs::symlink(&workspace_member_dir, &workspace_member_dir_symlink)
                    .context("while trying to symlink prebuilt workspace member directory")?;
            }
            None => {
                self.regenerate_workspace_nix()
                    .context("while regenerating workspace.nix")?;

                build_workspace(
                    self.project_dir(),
                    &self.workspace_nix(),
                    &workspace_member_dir_symlink,
                    "workspaceMemberDirectory",
                )
                .context("while building workspace member directory")?;
            }
        }

        let workspace_member_dir = workspace_member_dir_symlink;
        let mut workspace_members: Vec<String> = Vec::new();
        for entry in std::fs::read_dir(&workspace_member_dir).map_err(|e| {
            format_err!(
                "while iterating {} directory: {}",
                workspace_member_dir.to_string_lossy(),
                e
            )
        })? {
            let entry = entry.map_err(|e| {
                format_err!(
                    "while resolving entry in {} directory: {}",
                    workspace_member_dir.to_string_lossy().as_ref(),
                    e
                )
            })?;
            let path: PathBuf = entry.path();
            if path.is_dir() {
                workspace_members.push(path.file_name().unwrap().to_string_lossy().to_string());
            }
        }
        let workspace_context = crate::render::CargoTomlForWorkspace {
            info: crate::GenerateInfo::default(),
            workspace_member_dir: workspace_member_dir.to_string_lossy().into(),
            members: workspace_members,
        };

        // Generate Cargo.toml with workspace members.
        crate::render::CARGO_TOML_FOR_WORKSPACE
            .write_to_file(self.cargo_toml(), &workspace_context)?;

        cargo_generate_lockfile(self.project_dir(), self.cargo_toml())?;

        Ok(())
    }
}

fn cargo_generate_lockfile(
    project_dir: impl AsRef<Path>,
    cargo_toml: impl AsRef<Path>,
) -> Result<(), Error> {
    crate::command::run(
        "Updating Cargo.lock",
        Command::new("cargo").current_dir(&project_dir).args(&[
            "generate-lockfile",
            "--manifest-path",
            &cargo_toml.as_ref().to_string_lossy(),
        ]),
    )?;

    Ok(())
}

fn build_workspace(
    project_dir: impl AsRef<Path>,
    workspace_nix: impl AsRef<Path>,
    generated_workspace_symlink: impl AsRef<Path>,
    nix_attr: &str,
) -> Result<(), Error> {
    let project_dir = project_dir.as_ref().to_string_lossy().to_string();
    let workspace_nix = workspace_nix.as_ref().to_string_lossy().to_string();
    let caption = format!("Building {} {}", workspace_nix, nix_attr);
    crate::command::run(
        &caption,
        Command::new("nix").current_dir(&project_dir).args(&[
            "--show-trace",
            "build",
            "-f",
            &workspace_nix,
            nix_attr,
            "-o",
            generated_workspace_symlink
                .as_ref()
                .to_string_lossy()
                .as_ref(),
        ]),
    )?;

    Ok(())
}
