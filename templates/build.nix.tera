{# Argument: struct crate2nix::BuildInfo
   Rendered via https://tera.netlify.com
#}
# Generated by crate2nix {{info.crate2nix_version | safe}} with the command:
#  {% for arg in info.crate2nix_arguments %} {{arg}}{% endfor %}
# See https://github.com/kolloch/crate2nix for more info.

{ pkgs? import {{config.nixpkgs_path | safe}} { config = {}; },
  lib? pkgs.lib,
  callPackage? pkgs.callPackage,
  stdenv? pkgs.stdenv,
  buildRustCrate? pkgs.buildRustCrate,
  fetchurl? pkgs.fetchurl }:

rec {
    #
    # "public" attributes that we attempt to keep stable with new versions of crate2nix.
    #

    {% if root_package_id -%}
    # Use this attribute to refer to the derivation building your root crate.
    root_crate = crates.{{root_package_id}};
    {%- endif -%}
    {% if workspace_members %}
    # Refer your crate build derivation by name here.
    workspace_members = {
    {%- for name, pkg_id in workspace_members %}
        {{name}} = crates.{{pkg_id}};
    {%- endfor %}
    };
    {%- endif %}

    #
    # "private" attributes that may change in every new version of crate2nix.
    #

    crates = {
    {%- for crate in crates %}
        {{crate.package_id}}
            = buildRustCrate {
                crateName = {{crate.crate_name}};
                version = {{crate.version}};
                edition = {{crate.edition}};

                {%- if crate.has_bin and not crate.is_root_or_workspace_member %}
                # Hack to suppress building binaries
                crateBin = [{name = ","; path = ",";}];
                {%- endif -%}

                {%- if crate.source.CratesIo.sha256 %}
                sha256 = {{crate.source.CratesIo.sha256}};
                {%- elif crate.source.LocalDirectory.path %}
                src = (builtins.filterSource sourceFilter {{crate.source.LocalDirectory.path | safe}});
                {%- elif crate.source.Git %}
                src = builtins.fetchGit {
                    url = {{crate.source.Git.url}};
                    rev = {{crate.source.Git.rev}};
                };
                {%- else %}
                # ERROR: Could not resolve source: {{crate.source | safe | json_encode()}}
                {%- endif -%}

                {%- if crate.proc_macro %}
                procMacro = true;
                {%- endif -%}

                {%- if crate.build %}
                build = {{crate.build}};
                {%- endif -%}

                {%- if crate.lib_path %}
                libPath = {{crate.lib_path}};
                {%- endif -%}

                {%- if crate.authors|length > 0 %}
                authors = [
                {%- for author in crate.authors %}
                    {{author}}
                {%- endfor %}
                ];
                {%- endif -%}

                {%- if crate.dependencies|length > 0 %}
                dependencies = filterDeps [
                {%- for dependency in crate.dependencies %}
                    {%- if dependency.target %}
                    # target = {{dependency.target}}
                    (cfg {{dependency.target | safe | cfg_to_nix_expr}} {{dependency.package_id}})
                    {%- else %}
                    {{dependency.package_id}}
                    {%- endif -%}
                {%- endfor %}
                ];
                {%- endif -%}

                {%- if crate.build_dependencies|length > 0 %}
                buildDependencies = filterDeps [
                {%- for dependency in crate.build_dependencies %}
                    {%- if dependency.target %}
                    # target = {{dependency.target}}
                    (cfg {{dependency.target | safe | cfg_to_nix_expr}} {{dependency.package_id}})
                    {%- else %}
                    {{dependency.package_id}}
                    {%- endif -%}
                {%- endfor %}
                ];
                {%- endif -%}

                {%- if crate.features|length > 0 %}
                features = [
                {%- for feature in crate.features %}
                   {{feature}}
                {%- endfor %}
                ];
                {%- endif %}
            };
    {%- endfor %}
    };

    # Target (platform) data for conditional dependencies.
    # This corresponds to what buildRustCrate is setting.
    target = {
        unix = true;
        windows = false;

        # This doesn't appear to be officially documented anywhere yet.
        # See https://github.com/rust-lang-nursery/rust-forge/issues/101.
        os = if stdenv.hostPlatform.isDarwin
          then "macos"
          else stdenv.hostPlatform.parsed.kernel.name;
        arch = stdenv.hostPlatform.parsed.cpu.name;
        family = "unix";
        env = "gnu";
        endian = if stdenv.hostPlatform.parsed.cpu.significantByte.name == "littleEndian" then "little" else "big";
        pointer_width = toString stdenv.hostPlatform.parsed.cpu.bits;
        vendor = stdenv.hostPlatform.parsed.vendor.name;
        debug_assertions = false;
     };

    # Utility functions

    # Filter null package_ids and map the IDs to crate derivations.
    filterDeps = package_ids:
        let without_null = builtins.filter (x: ! (isNull x)) package_ids;
        in builtins.map (id: crates.${id}) without_null;

    # Trivial function to make package dependencies read nicer
    cfg = condition: package_id:
        if condition then package_id else null;

    # sourceFilter: Filters common temp files and build files
    # TODO(pkolloch): Substitute with gitignore filter
    sourceFilter = name: type:
        let baseName = builtins.baseNameOf (builtins.toString name);
        in ! (
          # Filter out git
          baseName == ".gitignore" ||
          (type == "directory" && baseName == ".git" ) ||

          # Filter out build results
          (type == "directory" && (
            baseName == "target" ||
            baseName == "_site" ||
            baseName == ".sass-cache" ||
            baseName == ".jekyll-metadata" ||
            baseName == "build-artifacts"
            )) ||

          # Filter out nix-build result symlinks
          (type == "symlink" && lib.hasPrefix "result" baseName) ||

          # Filter out IDE config
          (type == "directory" && (
            baseName == ".idea" ||
            baseName == ".vscode"
            )) ||
          lib.hasSuffix ".iml" baseName ||

          # Filter out nix build files
          lib.hasSuffix ".nix" baseName ||

          # Filter out editor backup / swap files.
          lib.hasSuffix "~" baseName ||
          builtins.match "^\\.sw[a-z]$" baseName != null ||
          builtins.match "^\\..*\\.sw[a-z]$" baseName != null ||
          lib.hasSuffix ".tmp" baseName ||
          lib.hasSuffix ".bak" baseName
        );

}
